---
title: 'Cr√©ditos'
description: 'Gerencie e acompanhe o consumo de cr√©ditos da sua conta'
---

## Vis√£o Geral

A API de Cr√©ditos permite monitorar o consumo, consultar hist√≥rico e analisar gastos de cr√©ditos em diferentes opera√ß√µes da plataforma.

<CardGroup cols={2}>
  <Card
    title="Hist√≥rico de Consumo"
    icon="clock-rotate-left"
    href="/api-reference/credits/history"
  >
    Veja todas as transa√ß√µes de cr√©ditos
  </Card>
  <Card
    title="Breakdown por Opera√ß√£o"
    icon="chart-pie"
    href="/api-reference/credits/breakdown"
  >
    Analise gastos por tipo de opera√ß√£o
  </Card>
</CardGroup>

## Como Funcionam os Cr√©ditos

Cada opera√ß√£o na API consome uma quantidade espec√≠fica de cr√©ditos:

| Opera√ß√£o | Cr√©ditos | Descri√ß√£o |
|----------|----------|-----------|
| **Valida√ß√£o de Link** | 1 | Validar link do WhatsApp |
| **Monitoramento (5min)** | 288/dia | Verifica√ß√£o a cada 5 minutos |
| **Monitoramento (1h)** | 24/dia | Verifica√ß√£o a cada hora |
| **Envio de Webhook** | 0.1 | Notifica√ß√£o via webhook |
| **An√°lise de Atividade** | 0.5 | Consulta de atividades |

## Casos de Uso

### Dashboard de Consumo

```javascript
async function getCreditsDashboard() {
  // Buscar hist√≥rico dos √∫ltimos 30 dias
  const history = await fetch(
    'https://api.monitoragrupo.com/v1/credits/history?period=30d',
    { headers: { 'Authorization': 'Bearer YOUR_TOKEN' } }
  ).then(r => r.json());
  
  // Buscar breakdown por opera√ß√£o
  const breakdown = await fetch(
    'https://api.monitoragrupo.com/v1/credits/breakdown?period=30d',
    { headers: { 'Authorization': 'Bearer YOUR_TOKEN' } }
  ).then(r => r.json());
  
  return {
    totalUsed: history.total_credits_used,
    remaining: history.credits_remaining,
    dailyAverage: history.total_credits_used / 30,
    topOperations: breakdown.by_operation.slice(0, 5),
    trend: history.daily_usage
  };
}

// Uso
const dashboard = await getCreditsDashboard();
console.log(`üí≥ Cr√©ditos restantes: ${dashboard.remaining.toLocaleString()}`);
console.log(`üìä M√©dia di√°ria: ${dashboard.dailyAverage.toFixed(0)} cr√©ditos`);
console.log(`üîù Top opera√ß√£o: ${dashboard.topOperations[0].name}`);
```

### Sistema de Alertas de Consumo

```python
import requests
from datetime import datetime

class CreditMonitor:
    def __init__(self, auth_token):
        self.headers = {'Authorization': f'Bearer {auth_token}'}
        self.base_url = 'https://api.monitoragrupo.com/v1'
    
    def check_credit_levels(self):
        """Verifica n√≠veis de cr√©dito e emite alertas"""
        response = requests.get(
            f'{self.base_url}/credits/history',
            headers=self.headers
        )
        
        data = response.json()
        remaining = data['credits_remaining']
        total = data['credits_total']
        percent_remaining = (remaining / total) * 100
        
        if percent_remaining <= 10:
            self.send_critical_alert(remaining, total)
        elif percent_remaining <= 25:
            self.send_warning_alert(remaining, total)
        
        return {
            'remaining': remaining,
            'total': total,
            'percent': percent_remaining,
            'status': self.get_status(percent_remaining)
        }
    
    def get_status(self, percent):
        if percent > 50:
            return 'üü¢ Saud√°vel'
        elif percent > 25:
            return 'üü° Aten√ß√£o'
        elif percent > 10:
            return 'üü† Baixo'
        else:
            return 'üî¥ Cr√≠tico'
    
    def predict_depletion_date(self):
        """Prev√™ quando os cr√©ditos ir√£o acabar"""
        response = requests.get(
            f'{self.base_url}/credits/history?period=7d',
            headers=self.headers
        )
        
        data = response.json()
        daily_usage = data['total_credits_used'] / 7
        remaining = data['credits_remaining']
        
        days_remaining = remaining / daily_usage if daily_usage > 0 else float('inf')
        
        return {
            'daily_average': daily_usage,
            'days_remaining': round(days_remaining, 1),
            'depletion_date': (datetime.now() + timedelta(days=days_remaining)).date()
        }
    
    def send_critical_alert(self, remaining, total):
        print(f"üö® ALERTA CR√çTICO: Apenas {remaining} cr√©ditos restantes ({(remaining/total)*100:.1f}%)")
        # Integrar com Slack, email, SMS, etc.
    
    def send_warning_alert(self, remaining, total):
        print(f"‚ö†Ô∏è AVISO: {remaining} cr√©ditos restantes ({(remaining/total)*100:.1f}%)")

# Uso
monitor = CreditMonitor('YOUR_TOKEN')

status = monitor.check_credit_levels()
print(f"Status: {status['status']}")
print(f"Restante: {status['remaining']:,} de {status['total']:,} ({status['percent']:.1f}%)")

prediction = monitor.predict_depletion_date()
print(f"\nüìÖ Previs√£o de esgotamento:")
print(f"   Consumo di√°rio m√©dio: {prediction['daily_average']:.0f} cr√©ditos")
print(f"   Dias restantes: {prediction['days_remaining']}")
print(f"   Data prevista: {prediction['depletion_date']}")
```

### An√°lise de Custos por Campanha

```javascript
class CreditAnalytics {
  constructor(authToken) {
    this.token = authToken;
    this.baseUrl = 'https://api.monitoragrupo.com/v1';
  }
  
  async getCampaignCosts(period = '30d') {
    const breakdown = await fetch(
      `${this.baseUrl}/credits/breakdown?period=${period}`,
      { headers: { 'Authorization': `Bearer ${this.token}` } }
    ).then(r => r.json());
    
    // Agrupar por campanha
    const campaignCosts = {};
    
    for (const item of breakdown.by_resource) {
      const campaign = item.campaign_id;
      
      if (!campaignCosts[campaign]) {
        campaignCosts[campaign] = {
          name: item.campaign_name,
          total_credits: 0,
          operations: {}
        };
      }
      
      campaignCosts[campaign].total_credits += item.credits_used;
      campaignCosts[campaign].operations[item.operation] = item.credits_used;
    }
    
    // Calcular ROI (exemplo: assumindo convers√µes conhecidas)
    for (const campaignId in campaignCosts) {
      const campaign = campaignCosts[campaignId];
      const conversions = await this.getConversions(campaignId);
      
      campaign.conversions = conversions;
      campaign.cost_per_conversion = campaign.total_credits / conversions;
      campaign.efficiency_score = this.calculateEfficiency(campaign);
    }
    
    return Object.values(campaignCosts).sort((a, b) => 
      b.efficiency_score - a.efficiency_score
    );
  }
  
  calculateEfficiency(campaign) {
    // Score de efici√™ncia: convers√µes / cr√©ditos gastos * 1000
    return (campaign.conversions / campaign.total_credits) * 1000;
  }
  
  async getConversions(campaignId) {
    // Buscar dados de convers√£o (implementar conforme sua API)
    return 150; // Exemplo
  }
  
  async generateOptimizationReport() {
    const campaigns = await this.getCampaignCosts('30d');
    
    console.log('\nüìä RELAT√ìRIO DE OTIMIZA√á√ÉO DE CR√âDITOS\n');
    console.log('='.repeat(70));
    
    campaigns.forEach((campaign, index) => {
      console.log(`\n${index + 1}. ${campaign.name}`);
      console.log(`   Cr√©ditos usados: ${campaign.total_credits.toLocaleString()}`);
      console.log(`   Convers√µes: ${campaign.conversions}`);
      console.log(`   Custo/Convers√£o: ${campaign.cost_per_conversion.toFixed(2)} cr√©ditos`);
      console.log(`   Score de efici√™ncia: ${campaign.efficiency_score.toFixed(2)}`);
      
      // Recomenda√ß√µes
      if (campaign.cost_per_conversion > 10) {
        console.log('   ‚ö†Ô∏è Recomenda√ß√£o: Otimizar frequ√™ncia de monitoramento');
      }
      if (campaign.efficiency_score < 5) {
        console.log('   ‚ö†Ô∏è Recomenda√ß√£o: Revisar targeting da campanha');
      }
    });
    
    return campaigns;
  }
}

// Uso
const analytics = new CreditAnalytics('YOUR_TOKEN');
await analytics.generateOptimizationReport();
```

## Otimiza√ß√£o de Consumo

### Recomenda√ß√µes por Plano

<Tabs>
  <Tab title="Plano Free (1.000 cr√©ditos/m√™s)">
    - **Monitores**: M√°ximo 2-3 grupos com intervalo de 1 hora
    - **Valida√ß√µes**: Apenas para links novos (n√£o revalidar)
    - **An√°lises**: Consultar atividades semanalmente
    - **Webhooks**: Usar com modera√ß√£o
  </Tab>
  
  <Tab title="Plano Pro (10.000 cr√©ditos/m√™s)">
    - **Monitores**: 10-15 grupos com intervalo de 15 minutos
    - **Valida√ß√µes**: Revalidar links a cada 7 dias
    - **An√°lises**: Consultar atividades diariamente
    - **Webhooks**: Configurar para eventos importantes
  </Tab>
  
  <Tab title="Plano Enterprise (Ilimitado)">
    - **Monitores**: Sem restri√ß√µes, use intervalos de 5 minutos
    - **Valida√ß√µes**: Revalidar links diariamente
    - **An√°lises**: Consultas em tempo real
    - **Webhooks**: Configurar para todos os eventos
  </Tab>
</Tabs>

### Estrat√©gias de Economia

<AccordionGroup>
  <Accordion title="Ajustar Frequ√™ncia de Monitoramento">
    Grupos est√°veis n√£o precisam ser verificados a cada 5 minutos. Use intervalos de 1 hora para grupos regulares.
  </Accordion>
  
  <Accordion title="Cache de Valida√ß√µes">
    Armazene resultados de valida√ß√µes e reutilize por 24-48 horas antes de revalidar.
  </Accordion>
  
  <Accordion title="Batch Operations">
    Agrupe opera√ß√µes quando poss√≠vel para reduzir overhead de requisi√ß√µes.
  </Accordion>
  
  <Accordion title="Desativar Monitores Inativos">
    Pause monitores de campanhas finalizadas ou em stand-by.
  </Accordion>
</AccordionGroup>

## Relat√≥rios Prontos

### Consumo Di√°rio

```bash
GET /credits/history?period=1d&group_by=hour
```

### Top Opera√ß√µes do M√™s

```bash
GET /credits/breakdown?period=30d&sort=credits_used&limit=10
```

### Tend√™ncia Semanal

```bash
GET /credits/history?period=7d&group_by=day
```

## Alertas Autom√°ticos

Configure notifica√ß√µes autom√°ticas baseadas em thresholds:

```json
{
  "alerts": {
    "low_credits": {
      "threshold": 1000,
      "notify": ["email", "webhook"],
      "message": "Cr√©ditos abaixo de 1.000"
    },
    "high_usage": {
      "daily_threshold": 500,
      "notify": ["slack"],
      "message": "Consumo di√°rio acima do normal"
    },
    "depletion_warning": {
      "days_remaining": 7,
      "notify": ["email", "sms"],
      "message": "Cr√©ditos acabar√£o em 7 dias"
    }
  }
}
```

## FAQ

<AccordionGroup>
  <Accordion title="Cr√©ditos expiram?">
    Cr√©ditos do plano mensal expiram ao final do per√≠odo de faturamento. Planos anuais t√™m validade de 12 meses.
  </Accordion>
  
  <Accordion title="Posso transferir cr√©ditos entre contas?">
    N√£o. Cr√©ditos s√£o vinculados √† conta e n√£o podem ser transferidos.
  </Accordion>
  
  <Accordion title="O que acontece quando os cr√©ditos acabam?">
    Monitores s√£o pausados automaticamente. Voc√™ ainda pode acessar a API para consultas b√°sicas, mas opera√ß√µes que consomem cr√©ditos ficam bloqueadas at√© recarga.
  </Accordion>
  
  <Accordion title="Como recarregar cr√©ditos?">
    Acesse o painel de billing em dashboard.monitoragrupo.com ou fa√ßa upgrade do plano.
  </Accordion>
</AccordionGroup>

## Integra√ß√µes Relacionadas

<CardGroup cols={2}>
  <Card
    title="Accounts"
    icon="user"
    href="/api-reference/accounts/overview"
  >
    Veja informa√ß√µes gerais da conta
  </Card>
  <Card
    title="Subscriptions"
    icon="credit-card"
    href="/api-reference/subscriptions/overview"
  >
    Gerencie sua assinatura e planos
  </Card>
  <Card
    title="Monitors"
    icon="radar"
    href="/api-reference/monitors/overview"
  >
    Otimize consumo de monitores
  </Card>
  <Card
    title="SmartLinks"
    icon="link"
    href="/api-reference/smartlinks/overview"
  >
    Gerencie valida√ß√µes de links
  </Card>
</CardGroup>
