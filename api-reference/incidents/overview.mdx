---
title: 'Incidentes'
description: 'Monitore e gerencie incidentes em grupos e links do WhatsApp'
---

## Vis√£o Geral

A API de Incidentes registra e analisa problemas detectados automaticamente em grupos, links e monitores. Receba notifica√ß√µes em tempo real e acesse hist√≥rico completo de incidentes.

<CardGroup cols={2}>
  <Card
    title="Incidentes de Monitores"
    icon="radar"
    href="/api-reference/incidents/monitors"
  >
    Veja incidentes detectados por monitores
  </Card>
  <Card
    title="Estat√≠sticas de Monitores"
    icon="chart-simple"
    href="/api-reference/incidents/monitors-stats"
  >
    An√°lise estat√≠stica de incidentes
  </Card>
  <Card
    title="Incidentes de Links"
    icon="link-slash"
    href="/api-reference/incidents/links"
  >
    Problemas detectados em SmartLinks
  </Card>
  <Card
    title="Estat√≠sticas de Links"
    icon="chart-line"
    href="/api-reference/incidents/links-stats"
  >
    M√©tricas e tend√™ncias de links
  </Card>
</CardGroup>

## Tipos de Incidentes

### Incidentes de Monitores

**Severidade Alta:**
- üî¥ **Grupo Inativo**: Grupo removido ou link inv√°lido
- üî¥ **Timeout**: Grupo n√£o responde ap√≥s m√∫ltiplas tentativas
- üî¥ **Capacidade Esgotada**: Grupo cheio sem backup

**Severidade M√©dia:**
- üü† **Resposta Lenta**: Tempo de resposta > 5 segundos
- üü† **Capacidade Cr√≠tica**: Grupo acima de 90% de ocupa√ß√£o
- üü† **Indisponibilidade Tempor√°ria**: Falha moment√¢nea

**Severidade Baixa:**
- üü° **Metadados Alterados**: Mudan√ßa em nome/descri√ß√£o do grupo
- üü° **Capacidade M√©dia**: Grupo acima de 75% de ocupa√ß√£o

### Incidentes de Links

**Problemas Comuns:**
- Link retorna 404 (N√£o encontrado)
- Link retorna 403 (Acesso negado)
- Redirecionamento inesperado
- Convite expirado
- Grupo exclu√≠do

## Ciclo de Vida de um Incidente

<Steps>
  <Step title="Detec√ß√£o">
    Monitor identifica problema automaticamente
  </Step>
  <Step title="Registro">
    Incidente √© criado com timestamp e contexto
  </Step>
  <Step title="Notifica√ß√£o">
    Alertas s√£o enviados via webhook/email/Slack
  </Step>
  <Step title="Investiga√ß√£o">
    Equipe analisa logs e m√©tricas
  </Step>
  <Step title="Resolu√ß√£o">
    Problema √© corrigido (manual ou autom√°tico)
  </Step>
  <Step title="Fechamento">
    Incidente marcado como resolvido
  </Step>
</Steps>

## Casos de Uso

### Painel de Incidentes em Tempo Real

```javascript
class IncidentDashboard {
  constructor(authToken) {
    this.token = authToken;
    this.baseUrl = 'https://api.monitoragrupo.com/v1';
  }
  
  async getActiveIncidents() {
    const [monitorIncidents, linkIncidents] = await Promise.all([
      fetch(`${this.baseUrl}/incidents/monitors?status=open`, {
        headers: { 'Authorization': `Bearer ${this.token}` }
      }).then(r => r.json()),
      
      fetch(`${this.baseUrl}/incidents/links?status=open`, {
        headers: { 'Authorization': `Bearer ${this.token}` }
      }).then(r => r.json())
    ]);
    
    return {
      monitors: monitorIncidents.incidents,
      links: linkIncidents.incidents,
      total: monitorIncidents.total + linkIncidents.total,
      critical: this.countBySeverity([...monitorIncidents.incidents, ...linkIncidents.incidents], 'critical')
    };
  }
  
  countBySeverity(incidents, severity) {
    return incidents.filter(i => i.severity === severity).length;
  }
  
  async getIncidentStats(period = '7d') {
    const stats = await fetch(
      `${this.baseUrl}/incidents/monitors-stats?period=${period}`,
      { headers: { 'Authorization': `Bearer ${this.token}` } }
    ).then(r => r.json());
    
    return {
      mttr: stats.mean_time_to_resolution,
      mtbf: stats.mean_time_between_failures,
      totalIncidents: stats.total_incidents,
      resolvedRate: (stats.resolved / stats.total_incidents * 100).toFixed(2),
      topIssues: stats.by_type.slice(0, 5)
    };
  }
  
  async renderDashboard() {
    const [active, stats] = await Promise.all([
      this.getActiveIncidents(),
      this.getIncidentStats('30d')
    ]);
    
    console.log('\nüö® PAINEL DE INCIDENTES\n');
    console.log('='.repeat(50));
    console.log(`\nüìä Ativos: ${active.total} (${active.critical} cr√≠ticos)`);
    console.log(`   Monitores: ${active.monitors.length}`);
    console.log(`   Links: ${active.links.length}\n`);
    
    console.log('üìà Estat√≠sticas (30 dias):');
    console.log(`   Total de incidentes: ${stats.totalIncidents}`);
    console.log(`   Taxa de resolu√ß√£o: ${stats.resolvedRate}%`);
    console.log(`   MTTR: ${stats.mttr} minutos`);
    console.log(`   MTBF: ${stats.mtbf} horas\n`);
    
    console.log('üîù Top 5 Problemas:');
    stats.topIssues.forEach((issue, index) => {
      console.log(`   ${index + 1}. ${issue.type}: ${issue.count} ocorr√™ncias`);
    });
  }
}

// Uso
const dashboard = new IncidentDashboard('YOUR_TOKEN');
await dashboard.renderDashboard();

// Atualizar a cada 30 segundos
setInterval(() => dashboard.renderDashboard(), 30000);
```

### Sistema de Auto-Resolu√ß√£o

```python
import requests
from datetime import datetime, timedelta

class IncidentResolver:
    def __init__(self, auth_token):
        self.headers = {'Authorization': f'Bearer {auth_token}'}
        self.base_url = 'https://api.monitoragrupo.com/v1'
    
    def auto_resolve_incidents(self):
        """Tenta resolver incidentes automaticamente"""
        response = requests.get(
            f'{self.base_url}/incidents/monitors?status=open',
            headers=self.headers
        )
        
        incidents = response.json()['incidents']
        resolved = []
        
        for incident in incidents:
            resolution = None
            
            if incident['type'] == 'capacity_full':
                resolution = self.handle_capacity_full(incident)
            elif incident['type'] == 'link_inactive':
                resolution = self.handle_link_inactive(incident)
            elif incident['type'] == 'slow_response':
                resolution = self.handle_slow_response(incident)
            
            if resolution:
                self.mark_resolved(incident['id'], resolution)
                resolved.append(incident)
        
        return {
            'total_processed': len(incidents),
            'auto_resolved': len(resolved),
            'manual_review': len(incidents) - len(resolved)
        }
    
    def handle_capacity_full(self, incident):
        """Rotaciona para pr√≥ximo grupo dispon√≠vel"""
        campaign_id = incident['metadata']['campaign_id']
        
        # Buscar pr√≥ximo grupo dispon√≠vel
        response = requests.get(
            f'{self.base_url}/campaigns/{campaign_id}/groups',
            headers=self.headers
        )
        
        groups = response.json()['groups']
        available = [g for g in groups if g['current_members'] < g['max_capacity']]
        
        if available:
            next_group = min(available, key=lambda g: g['current_members'])
            
            # Atualizar SmartLink
            requests.put(
                f'{self.base_url}/smartlinks/{incident["resource_id"]}/details',
                headers=self.headers,
                json={'group_id': next_group['id']}
            )
            
            return f"Rotacionado para grupo {next_group['name']}"
        
        return None  # N√£o foi poss√≠vel resolver
    
    def handle_link_inactive(self, incident):
        """Desativa link e notifica administrador"""
        link_id = incident['resource_id']
        
        # Desativar link
        requests.put(
            f'{self.base_url}/smartlinks/{link_id}/details',
            headers=self.headers,
            json={'is_active': False}
        )
        
        # Enviar notifica√ß√£o
        self.send_notification({
            'level': 'critical',
            'message': f'Link {link_id} foi desativado automaticamente',
            'action_required': 'Verificar e atualizar link'
        })
        
        return "Link desativado, administrador notificado"
    
    def handle_slow_response(self, incident):
        """Ajusta timeout e retry do monitor"""
        monitor_id = incident['monitor_id']
        
        requests.put(
            f'{self.base_url}/monitors/{monitor_id}',
            headers=self.headers,
            json={
                'timeout': incident['metadata']['timeout'] * 1.5,
                'retry_attempts': 3
            }
        )
        
        return "Timeout ajustado, adicionado retry policy"
    
    def mark_resolved(self, incident_id, resolution_notes):
        requests.put(
            f'{self.base_url}/incidents/{incident_id}/resolve',
            headers=self.headers,
            json={
                'status': 'resolved',
                'resolution_notes': resolution_notes,
                'resolved_at': datetime.now().isoformat(),
                'resolved_by': 'auto_resolver'
            }
        )
    
    def send_notification(self, data):
        # Implementar integra√ß√£o com Slack, email, etc.
        print(f"üìß Notifica√ß√£o: {data['message']}")

# Executar a cada 5 minutos
resolver = IncidentResolver('YOUR_TOKEN')
result = resolver.auto_resolve_incidents()

print(f"‚úÖ {result['auto_resolved']} incidentes resolvidos automaticamente")
print(f"‚ö†Ô∏è {result['manual_review']} requerem revis√£o manual")
```

### An√°lise de Tend√™ncias

```javascript
async function analyzeIncidentTrends(days = 30) {
  const response = await fetch(
    `https://api.monitoragrupo.com/v1/incidents/monitors-stats?period=${days}d`,
    { headers: { 'Authorization': 'Bearer YOUR_TOKEN' } }
  );
  
  const stats = await response.json();
  
  // An√°lise de padr√µes temporais
  const hourlyDistribution = stats.by_hour;
  const peakHour = Object.entries(hourlyDistribution)
    .sort(([,a], [,b]) => b - a)[0];
  
  // An√°lise de tipos recorrentes
  const recurringIssues = stats.by_type
    .filter(t => t.count > 5 && t.recurrence_rate > 0.3);
  
  // Calcular tend√™ncia (crescente/decrescente)
  const trend = calculateTrend(stats.daily_incidents);
  
  return {
    peakHour: { hour: peakHour[0], incidents: peakHour[1] },
    recurringIssues,
    trend,
    recommendations: generateRecommendations(stats)
  };
}

function calculateTrend(dailyData) {
  const recent = dailyData.slice(-7).reduce((a, b) => a + b, 0) / 7;
  const previous = dailyData.slice(-14, -7).reduce((a, b) => a + b, 0) / 7;
  
  const change = ((recent - previous) / previous * 100).toFixed(1);
  
  return {
    direction: recent > previous ? 'increasing' : 'decreasing',
    change: Math.abs(change) + '%',
    status: recent > previous ? 'üìà' : 'üìâ'
  };
}

function generateRecommendations(stats) {
  const recommendations = [];
  
  if (stats.mttr > 60) {
    recommendations.push('‚ö° MTTR alto - Configure auto-resolu√ß√£o para incidentes comuns');
  }
  
  if (stats.total_incidents > 100) {
    recommendations.push('üéØ Volume alto - Revise thresholds dos monitores');
  }
  
  const capacityIssues = stats.by_type.find(t => t.type === 'capacity_full');
  if (capacityIssues && capacityIssues.count > 20) {
    recommendations.push('‚ûï Incidentes de capacidade - Adicione mais grupos √†s campanhas');
  }
  
  return recommendations;
}

// Uso
const analysis = await analyzeIncidentTrends(30);
console.log('üìä AN√ÅLISE DE TEND√äNCIAS\n');
console.log(`${analysis.trend.status} Tend√™ncia: ${analysis.trend.direction} (${analysis.trend.change})`);
console.log(`‚è∞ Pico de incidentes: ${analysis.peakHour.hour}h (${analysis.peakHour.incidents} ocorr√™ncias)\n`);
console.log('üí° Recomenda√ß√µes:');
analysis.recommendations.forEach(rec => console.log(`   ${rec}`));
```

## M√©tricas de SLA

<CardGroup cols={2}>
  <Card title="MTTR" icon="clock">
    Mean Time To Resolution - Tempo m√©dio at√© resolu√ß√£o
  </Card>
  <Card title="MTBF" icon="gauge-high">
    Mean Time Between Failures - Tempo m√©dio entre falhas
  </Card>
  <Card title="Uptime" icon="arrow-trend-up">
    Percentual de disponibilidade dos recursos
  </Card>
  <Card title="SLA Compliance" icon="certificate">
    Conformidade com acordos de n√≠vel de servi√ßo
  </Card>
</CardGroup>

## N√≠veis de Severidade

| N√≠vel | Emoji | Descri√ß√£o | SLA | A√ß√£o |
|-------|-------|-----------|-----|------|
| **Critical** | üî¥ | Servi√ßo indispon√≠vel | 15 min | Alerta imediato |
| **High** | üü† | Degrada√ß√£o severa | 1 hora | Notifica√ß√£o urgente |
| **Medium** | üü° | Problema moderado | 4 horas | Revis√£o necess√°ria |
| **Low** | üü¢ | Alerta informativo | 24 horas | Log apenas |

## Webhooks de Incidentes

Configure webhooks para receber notifica√ß√µes em tempo real:

```json
{
  "event": "incident.created",
  "incident": {
    "id": "inc_abc123",
    "type": "link_inactive",
    "severity": "critical",
    "resource_type": "smartlink",
    "resource_id": "sl_xyz789",
    "detected_at": "2026-01-09T14:30:00Z",
    "message": "Link retornou 404 ap√≥s 3 tentativas",
    "metadata": {
      "monitor_id": "mon_123",
      "campaign_id": "camp_456",
      "last_successful_check": "2026-01-09T14:15:00Z"
    }
  }
}
```

## Melhores Pr√°ticas

<AccordionGroup>
  <Accordion title="Configure Alertas Inteligentes">
    Use n√≠veis de severidade para direcionar notifica√ß√µes apenas para problemas cr√≠ticos.
  </Accordion>
  
  <Accordion title="Automatize Resolu√ß√µes Comuns">
    Implemente scripts para resolver automaticamente incidentes recorrentes (rota√ß√£o de grupos, ajuste de timeouts).
  </Accordion>
  
  <Accordion title="Analise Tend√™ncias Regularmente">
    Revise estat√≠sticas semanalmente para identificar padr√µes e prevenir problemas futuros.
  </Accordion>
  
  <Accordion title="Documente Post-Mortems">
    Para incidentes cr√≠ticos, documente causa raiz e a√ß√µes preventivas.
  </Accordion>
</AccordionGroup>

## Integra√ß√µes Relacionadas

<CardGroup cols={2}>
  <Card
    title="Monitors"
    icon="radar"
    href="/api-reference/monitors/overview"
  >
    Configure monitores que detectam incidentes
  </Card>
  <Card
    title="SmartLinks"
    icon="link"
    href="/api-reference/smartlinks/overview"
  >
    Gerencie links que podem gerar incidentes
  </Card>
  <Card
    title="Webhooks"
    icon="webhook"
    href="/webhooks/overview"
  >
    Receba notifica√ß√µes de incidentes
  </Card>
  <Card
    title="Groups"
    icon="users"
    href="/api-reference/groups/overview"
  >
    Administre grupos relacionados a incidentes
  </Card>
</CardGroup>
